
session token: provides groupId, subgroupId (studentId)
TEACHER-GROUP-HASH-FIRSTNAME

-> info to load critical elements
   modelId -> pmcdata Prop, Mech, Evidence
    Prop, Mech -> SVGView
    Evidence -> ResourceLibrary, ResourceView, Prop, Mech

   resourceId -> Array<Resource> ->  ResourceLibrary, ResourceView
   criteria -> CommentUI

  [teachers] teacherId -> [classrooms] classroomId -> [groups] groupId -> studentIds
  [models] modelId -> [pmc nodes, mechanisms, evidence] node,mech,ev -> [comments]

  classroomId -> [criteria] criterion - popup menus in stickynotes
              -> [selectedResources] resource
              -> [sentenceStarters] sentence {string}

  global [ratings] rating - rating key / legend  for stars {signed int}
  global [resources] resource - master list of all resources in system


IMPLEMENTING DATA INITIALIZATION

When running the server from dev, we want to always load the hardcoded data.
When running the server from electron, we want to initialize the database.

Q. What happens with the runtime folder when making the electron build?
A. meme.app/Contents/Resources/runtime/

Q. How to tell if dev or electron?
A. npm run dev runs meme.js, which loads server.js as URSERVER, which calls
   InitializeNetwork(), StartNetwork(), and StartWebServer().
   Electron builds are invoked through app-console/console-main.js instead.

We'll start with ADMIN UPDATES

o  PKT_Update() will receive a data objects with arrays of change objects
o  It will return the array of dataobjects that were successfully transformed
o  It will set the data.error property if there was a problem

How to determine whether NET or LOCAL
ultimately this is handled at the MESSAGER and NETMESSAGE level

On the sending end

* URLINK.Call() calls MESSAGER.CallAsync(mesgName, inData, options)
* MESSAGER.CAllAsync() determines whether it goes to the network or is handled locally
* path 1: if it's a local call and there are handlers, make a Resolver Promise
* path 2: if it's a network call, make a NetMessage() and make a Transaction Promise

On the receiving end: server-network largely is a switchboard

* pkt is sent to m_HandleMessage()
* packets know how to route themselves via available socket
* a completed transaction is one that's returning from elsewhere
* otherwise see if we have any handlers available for this packet's message via m_PromiseRemoteHandlers()
* this creates a new packet transaction via PromiseTransaction(), which will return here as a ReturnTransaction()

How are messages registered?

SO WHAT DOES THIS MEAN FOR CHANNELS?

* detected : channel
* set the toNet, toLocal flags based on that
* registering messages are done without the NET:

UPDATING MESSAGER

x - write a splitter function ParseMessage(msg) return { channel, message }
x - Publish is for sending
    x - replace toNet with NET, toLocal with LOCAL
    o - remove NetPublish
~ - Subscribe is for receiving
    o - replace fromNet with NET
    o - remove NetSubscribe
o - CallAsync is send/receive data

o - Signal is send only

\
DEBUGGING:
when changing Messager.Subscribe() to use ParseMessage(), network breaks.

Messager.Publish() uses ParseMessage().
URLink.NetPublish() removed.
Change SRV_* to NET:SRV_* for messages.

OK1 - is it when NetSubscribe is used on Server?
    - in server.js. It seems that this works in test, admin, and
OK2 - is it when NetSubscribe is used on Client?
      network-tests still pass
OK3 - is it when NetSubscribe is handling Transactions?
      network-tests still pass

URLink.LocalPublish() removed.
.. OK1, OK2, OK3

Messager.Subscribe() use ParseMessage().
.. option fromNet is set true by NetSubscribe, LocalSend, and LocalCall
   NetSubscribe called from network-tests, ursus
   URLINK.LocalSend called from ur-network as part of msend protocol
   .. HandleMessage: ULINK.LocalSend(fromNet:true), pkt.ReturnTransaction()
   URLINK.LocalCall is called from ur-network as part of mcall protocol
   .. HandleMessage: ULINK.LocalCall(fromNet:true) then pktSetData, pktReturnTranaction
.. otherwise fromNet is default to false
REVIEW: fromNet is a flag that's set only for calls that are invoked from the network,
meaning they cam in via ur-network.HandleMessage()

A remote Send, Signal, or Call always returns a transaction
A remote Send, Signal, or Call always set fromNet:true
A remote Send, Signal, or Call should always have the CHANNEL in its name
publish replaces send, but still uses type 'msend'
There's also a 'direction' flag that's set

IMPORTANT:

    NET calls that do not terminate at the server are cloned and sent to remotes,
    then reassembled!

So what have we done so far?

    Aded NET: to net calls, registered messages.

    m_HandleMessage() exists BOTH on ur-network and server-network, and uses the
    pkt.IsResponse() to determine when to complete transaction for itself.
    The pkt.IsRequest() is not used though.

    It's worth noting that on the client side, m_HandleMessage() is used to
    handle network-sourced messages only. They invoke a ULINK call.
    There is a single ULINK instance for all network elements from the network.

    ULINK.LocalSignal(msg,data,{fromNet:true})
    ULINK.LocalSend(msg,data,{fromNet:true});
    ULINK.LocalCall(msg,data,{fromNet:true}).then(result=>{
        pkt.SetData(result);
        pkt.ReturnTransaction();
    }

    All the incoming messages should be preceded with NET:, as we're not
    processing them at all. So a single CALL methods should determine what to do.

Q. What is the difference between LocalCall(), Call(), and NetCall() in ULINK?
A. From m_HandleMessage(), these are all invoked with fromNet: true

   LocalCall(mesgName, inData, options)
    -> set LOCAL true, NET false
    -> return forwarded Call()
   NetCall(mesgName, inData, options)
   -> set LOCAL false, NET true
   -> return forwarded Call()
   *MASTER*
   Call(mesgName, inData, options)
    -> sets srcUID to ulink's ID
    -> MESSAGER.CallAsync(mesgName, inData, options)

   in MESSAGER.CallAsync(mesgName, inData, options)
   -> uses LOCAL, NET to select DESTINATION
   -> grabs fromNET to indicate it's a REMOTE INCOMING CALL

   for the handling of a remote message, m_HandlerMessage()
   purposefully calls LocalCall to set LOCAL and unset NET.
   the actual calls are handled in the await Promise.all(promises)

Q. So how to eliminate LocalCall and NetCall in favor of a single call?
A. The incoming NET:MESSAGE needs to be converted to MESSAGE
   in m_HandleMessage() line 218ish:
      use { MESSAGE } = NetMessage.DecodeChannel(pkt)
      use ULINK.Call() without the complete message to force local call

    ***
    the trick is that Call needs to determine what style of invocation to use.
    Only calls wthat have NET: in them respond to local calls.
    However, NET: sets the flag to call the network, NOT the local call.
    SO...we probably still need the flag because the entire MESSAGE has NET in it.
    ***

    *** rewrite Call to handle fromNet to invoke NET:MESSAGE using local signaling

IMPLEMENTING THE CHANGE

o - ur-network.m_HandleMessage() uses its ULINK.Call() without the channel.
o - however the message is registered with 'NET:' in front of it and that's how it's stored
o - maybe the solution is to have MESSAGER actually store the handlers with the flags, but without the channels.

Subscribe('NET:MYMESSAGE',data=>{});
Publish('NET:MYSMESSAGE',data);
Call('NET:MYMESSAGE',data).then(data=>{});
Signal('NET:MYSMESSAGE',data); // system wide

SetState('NET:state', state).then(state=>{});
GetState('NET:state').then(state=>{});
OnState('NET:state',state=>{});

First fix SUBSCRIBE
NetSubscribe is setting fromNet, which is kind of bogus.
handlerFunc.fromNet is used in two different ways???
x - update network-tests to replace NetSubscribe with Subscribe
x - update messager.subscribe() to use CHANNEL EXTRACT
x - update messager.callasync() to read handlerFunc.channels.net

registered handlers no longer include CHANNEL: in registered message.

Now fix
x - LocalCall() change to use Call()
x - UndefinedLocalCall() change to use Call()
o - NetCall() change to use Call() 'NET:MYSTERY_REMOTE'
    NET:MYSTERY_REMOTE NOTE FOUND

*** PUNT ***
*** PUNT ***
*** PUNT ***
*** Can not cleanly add CHANNEL SUPPORT without rewriting tests
    from scratch, and also working out th channel strategy from
    a signaling perspective.


--- ok --- what to do about updates ---

Our data structures on the db side are COLLECTIONS in a LokiDB.
These are an in-memory data structure.

Use one of the names from DATAMAP.DBKEYS

NET:SRV_DB_ADD, {
    <dbkey>: {} or [{}...{}]
} return {
    <dbkey>: rewritten objects or array
    error: 'set if there was an error'
}

NET:SRV_DB_UPDATE, {
    <dbkey>: {} or [{}...{}] // must have ids set
}

NET:SRV_DB_DELETE, {
    <dbkey>: id || [id,...]
}

NET:SRV_DB_QUERY, {
    <dbkey>: condition || [ condition, condition, ... ]
}

---

  teacher / classroom / group / student (in students)

  teachers.db.js    - array of { id, name }
  classrooms.db.js  - array of { id, name, teacherId }
  groups.db.js      - array of { id, name, students [], classroomId }
  models.db.js      - array of { id, title, groupId, etc }
  resources.db.js   - array of { id, referenceLabel, etc }


--- ok ---
now that these calls are available and capable of firing back their changes, we can    try implementing PMC data

PMCDATA.InitializeModel(model,resources)
PMCDATA.PMC_AddProp(node)
PMCDATA.PMC_SetPropParent(node,parent)
PMCDATA.PMC_PropDelete(propid)
PMCDATA.PMC_MechAdd(sourceId,targetId,label)
PMCDATA.PMC_MechUpdate(origMech,newMech)
PMCDATA.PMC_MechDelete(mechId)
PMCDATA.PMC_DeleteEvidenceLink(evId)
PMCDATA.SetEvidenceLinkPropId(evId,propId)

BuildModel() is called whenever the properties are changed.

ALL METHODS IN PMC-DATA REVIEW
B = calls BuildModel()
D = publishes DATA_UPDATED
S = publishes SELECTION_CHANGED

    ---
    PMCData.Graph = ()
 D  PMCData.BuildModel = ()
    ---
B   PMCData.InitializeModel = (model, resources)
    PMCData.AllProps = ()
    PMCData.AllMechs = ()
    PMCData.Components = ()
    PMCData.Children = nodeId
    PMCData.HasProp = nodeId
    PMCData.HasMech = (evo, ew)
    PMCData.Prop = nodeId
    PMCData.PropParent = nodeId
    PMCData.Mech = (evo, ew)
    ---
B   PMCData.PMC_AddProp = node
B   PMCData.PMC_SetPropParent = (node, parent)
B   PMCData.PMC_PropDelete = propid
B   PMCData.PMC_MechAdd = (sourceId, targetId, label)
B   PMCData.PMC_MechUpdate = (origMech, newMech)
B   PMCData.PMC_MechDelete = mechId
B   PMCData.PMC_AddEvidenceLink = (rsrcId, note = '')
    PMCData.PMC_GetResourceIndex = rsrcId
B   PMCData.PMC_DuplicateEvidenceLink = evId
B   PMCData.PMC_DeleteEvidenceLink = evId
    PMCData.PMC_GetEvLinkByEvId = evId
    PMCData.PMC_GetEvLinksByPropId = propid
    PMCData.PMC_GetEvLinksByMechId = mechId
    ---
B   PMCData.SetEvidenceLinkPropId = (evId, propId)
B   PMCData.SetEvidenceLinkMechId = (evId, mechId)
 D  PMCData.SetEvidenceLinkNote = (evId, note)
 D  PMCData.SetEvidenceLinkRating = (evId, rating)
    PMCData.GetComments = id
    PMCData.NewComment = (author, sentenceStarter)
 D  PMCData.UpdateComments = (parentId, comments)
    PMCData.GetPropIdsByResourceId = rsrcId
    PMCData.GetEvLinksByResourceId = rsrcId
    ---
    VMData.VM_GetVPropChanges = ()
    VMData.VM_VPropExists = nodeId
    VMData.VM_VProp = nodeId
    VMData.VM_VPropDelete = nodeId --- should be selection aware
    VMData.VM_VPropSet = (nodeId, vprop)
    VMData.VM_GetVMechChanges = () --- should use DATAMAP
    VMData.VM_VMechExists = (evo, ew)
    VMData.VM_VMech = (evo, ew)
    VMData.VM_VMechDelete = (evo, ew) --- should be selection aware
    VMData.VM_VMechSet = (vmech, evo, ew)
  S VMData.VM_SelectAddProp = vprop
  S VMData.VM_SelectProp = vprop
    VMData.VM_PropMouseEnter = vprop
    VMData.VM_PropMouseExit = vprop
    VMData.VM_PropsMouseOver = ()
    VMData.VM_SetSelectionLimit = max
  S VMData.VM_DeselectProp = vprop
  S VMData.VM_ToggleProp = vprop
  S VMData.VM_DeselectAllProps = ()
    VMData.VM_DeselectAllMechs = ()
    VMData.VM_DeselectAll = ()
  S VMData.VM_SelectOneMech = vmech
  S VMData.VM_ToggleMech = vmech
    VMData.VM_SelectedPropsIds = ()
    VMData.VM_SelectedMechIds = ()

    B = calls BuildModel()
    D = publishes DATA_UPDATED
    S = publishes SELECTION_CHANGED

--- some observations ---

*** BuildModel() to recreate the model
    and 'DATA_UPDATED', 'ADM_DATA_UPDATED' are the main triggers

    first update BuildModel() to be called whenever a DB_SYNC event happens.
    so DBSYNC should be written first. It's in data.js hooked during INITIALIZE
    to capture NET:SYSTEM_DBSYNC

    Ok, once this sync message is available, let's try modifying a call.
    (1) there are one of three calls: NET:SRV_DBADD, DBUPDATE, DBREMOVE
    These all expect a data packet

The generic format would look something like:

MIR.SendDataOp = (data, opmsg)=>new Promise((resolve,reject)=>{
            UR.NetCall(opmsg,data)
            .then(rdata=> resolve(rdata))
            .catch(error=>reject(error))
        });

MIR.AddTeacher = name => {
  return new Promise((resolve, reject) => {
    UR.NetCall('NET:SRV_DBADD', {
      teachers: { name }
    })
      .then(rdata => resolve(rdata))
      .catch(error => reject(error));
  });
};

MIR.UpdateGroup = (groupId, group) => {
  return new Promise((resolve, reject) => {
    const groupData = Object.assign({}, group, { id: groupId });
    UR.NetCall('NET:SRV_DBUPDATE', {
      groups: [groupData]
    })
      .then(rdata => resolve(rdata))
      .catch(error => reject(error));
  });
};

MIR.DeleteGroup = groupId => {
  return new Promise((resolve, reject) => {
    UR.NetCall('NET:SRV_DBREMOVE', {
      groups: [groupId]
    })
      .then(rdata => resolve(rdata))
      .catch(error => reject(error));
  });
};

